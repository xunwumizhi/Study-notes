# Linux 性能优化实战

## CPU 性能
### 平均负载(Load Average)

压测
```bash
uptime
# 02:34:03 # 当前时间
# up 2 days, 20:14,  1 user,  # 系统运行时长
# load average: 0.63, 0.83, 0.88 # 过去 1 分钟、5 分钟、15 分钟的平均负载
man uptime
# top 第一行信息包含了 uptime
top 

# 查看 CPU 个数（核数）
grep "processor" /proc/cpuinfo

# stress 提高压力
stress --cpu 1 --timeout 600
watch -d update

# 多核 CPU 状态工具 -P指定CPU 5统计间隔 1输出一次
mpstat -P ALL 5 1
# 多核进程状态分析工具 pidstat -u 5 1
pidstat -u 5 1
# -d 分析 io
# -w 分析 switch
```

### 上下文切换

多任务管理，切换任务时，需要保存 CPU 寄存器和程序计数器等上下文

根据任务的不同，CPU 的上下文切换就可以分为几个不同的场景，也就是进程上下文切换、线程上下文切换以及中断上下文切换。

- 进程 CPU 上下文切换

进程上下文切换，是指从一个进程切换到另一个进程运行。

而系统调用过程中一直是同一个进程在运行。所以，系统调用过程通常称为特权模式切换，而不是上下文切换。但实际上，系统调用过程中，CPU 的上下文切换还是无法避免的。
CPU 寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务。而系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。所以，一次系统调用的过程，其实是发生了两次 CPU 上下文切换。

- 线程 CPU 上下文切换

同进程内的线程切换，要比多进程间的切换消耗更少的资源，而这，也正是多线程代替多进程的一个优势。

- 中断 CPU 上下文切换

跟进程上下文不同，中断上下文切换并不涉及到进程的用户态。对同一个 CPU 来说，中断处理比进程拥有更高的优先级，所以中断上下文切换并不会与进程上下文切换同时发生。同样道理，由于中断会打断正常进程的调度和执行，所以大部分中断处理程序都短小精悍，以便尽可能快的执行结束。

vmstat 是一个常用的系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析 CPU 上下文切换和中断的次数。

每隔5秒输出1组数据
$ vmstat 5

cs（context switch）是每秒上下文切换的次数。

in（interrupt）则是每秒中断的次数。

r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。b（Blocked）则是处于不可中断睡眠状态的进程数。

- 查看具体进程上下文切换 

每隔5秒输出1组数据 上下文切换信息
$ pidstat -w 5

一个是  cswch  ，表示每秒自愿上下文切换（voluntary context switches）的次数，

另一个则是  nvcswch  ，表示每秒非自愿上下文切换（non voluntary context switches）的次数。

所谓自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。

而非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。

- 查看中断

/proc/interrupts 查看硬中断
/proc/softirqs 软中断

Linux 通过 /proc 虚拟文件系统，向用户空间提供了系统内部状态的信息

Linux 中的中断处理程序分为上半部和下半部：上半部对应硬件中断，用来快速处理中断。下半部对应软中断，用来异步处理上半部未完成的工作。

网卡接收到数据包后，会通过硬件中断的方式，通知内核有新的数据到了。这时，内核就应该调用中断处理程序来响应它。你可以自己先想一下，这种情况下的上半部和下半部分别负责什么工作呢？对上半部来说，既然是快速处理，其实就是要把网卡的数据读到内存中，然后更新一下硬件寄存器的状态（表示数据已经读好了），

最后再发送一个软中断信号，通知下半部做进一步的处理。而下半部被软中断信号唤醒后，需要从内存中找到网络数据，再按照网络协议栈，对数据进行逐层解析和处理，直到把它送给应用程序。

> list
```bash
# 系统切换总览
vmstat 5
# 进程切换
pidstat -w

# 中断
cat /proc/interrupts
cat /proc/stat |grep ^cpu
```

### 进程 CPU 分析

通过 top、ps、pidstat 等工具，你能够轻松找到 CPU 使用率较高的进程

占用 CPU 的到底是代码里的哪个函数呢？找到它，你才能更高效、更针对性地进行优化。除了 GDB 还可以用 perf 来分析

第一种常见用法是 perf top，类似于 top，它能够实时显示占用 CPU 时钟最多的函数或者指令，因此可以用来查找热点函数


命令list
```bash
# 分析某个进程函数分析 -g 显示调用
# 实时
sudo perf top -g -p <pid>
# 采集后再看
perf record -g
perf report

# 查看进程调用，找到父进程
pstree | grep stress
```


## 内存

## 文件系统

索引节点（index node, inode）和目录项（directory entry, dentry）

虚拟文件系统 VFS（Virtual File System）。

第一种，根据是否利用标准库缓存，可以把文件 I/O 分为缓冲 I/O 与非缓冲 I/O。缓冲 I/O，是指利用标准库缓存来加速文件的访问，而标准库内部再通过系统调度访问文件。非缓冲 I/O，是指直接通过系统调用来访问文件，不再经过标准库缓存。

第二，根据是否利用操作系统的页缓存，可以把文件 I/O 分为直接 I/O 与非直接 I/O。直接 I/O，是指跳过操作系统的页缓存，直接跟文件系统交互来访问文件。非直接 I/O 正好相反，文件读写时，先要经过系统的页缓存，然后再由内核或额外的系统调用，真正写入磁盘。

不过要注意，直接 I/O、非直接 I/O，本质上还是和文件系统交互。和裸 I/O 概念不一样，如果是在数据库等场景中，你还会看到，跳过文件系统读写磁盘的情况，也就是我们通常所说的裸 I/O。

![](https://static001.geekbang.org/resource/image/32/47/328d942a38230a973f11bae67307be47.png?wh=836*507)

![](https://static001.geekbang.org/resource/image/72/12/728b7b39252a1e23a7a223cdf4aa1612.png?wh=530*590)
