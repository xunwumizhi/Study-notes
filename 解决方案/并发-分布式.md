## 并发安全

### 并发与并行

并发，指的是多个事情，在同一时间段内同时发生了。
并行，指的是多个事情，在同一时间点上同时发生了。

并发的多个任务之间是互相抢占资源的。 
并行的多个任务之间是不互相抢占资源的、

只有在多CPU的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。



### 乐观锁、悲观锁

悲观锁：保守的并发控制手段，直接用锁控制，保证并发安全

乐观锁：认为发部分情况下，没有并发冲突，在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测。简而言之，尽可能不加锁情况下实现安全。

乐观锁实现：基于CAS比较并交换，增加version版本机制

- CAS 即比较并替换，实现并发算法时常用到的一种技术。CAS操作包含三个操作数——内存位置、预期原值及新值。执行CAS操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作，返回更新失败信息。

  比如说给你儿子订婚。你儿子就是内存位置，你原本以为你儿子是和杨贵妃在一起了，结果在订婚的时候发现儿子身边是西施。这时候该怎么办呢？你一气之下不做任何操作。如果儿子身边是你预想的杨贵妃，你一看很开心就给他们订婚了，也叫作执行操作。

CAS由于只比较操作前的值，不能知道有没有其他线程ABA更新过字段，因此给数据体加上版本字段。

高并发情况下，大量操作会失败，设置自动重试：固定失败重试次数，或者在指定时间范围内不断重试。

> Redis乐观锁解决高并发抢红包的问题  http://c.biancheng.net/view/4603.html 

> Go是如何实现乐观锁（CAS理论） - 知乎  https://zhuanlan.zhihu.com/p/159334753



## 分布式理论、名词

分布式性能指标：CAP，可实现版本：Base，基本可用(Basically Available）、软状态(Soft State)、最终一致性(Eventual Consistency)。其中一致性是问题核心

共识是指导实现一致性的理论，包括Paxos，Raft

一致性的分级程度：



- 线性一致性Linearizability consistency ，也叫原子性。       Raft
- 顺序一致性 Sequential consistency：							        ZooKeeper
- 因果一致性 Causal consistency
- 最终一致性 Eventual consistency



理论的工程实现

Raft：etcd

Paxos: ZK



## etcd

```
s, err := concurrency.NewSession(c, concurrency.WithTTL(15))
e := concurrency.NewElection(s, keyPrifex)

ctx, ctxCancel := context.WithCancel(context.TODO())
defer ctxCancel()
if err = e.Campaign(ctx, keyValue); err != nil {
    fmt.Println(err)
    return
}

select {
case <-stop:
case <-s.Done(): // 等待lease过期，但由于session为lease自动续约，过期时意味着ctx关闭，session退出，到期后没续约
    log.Println(w.name, "elect: expired")
}
// 辞职
e.Resign(context.TODO()) // 传递一个新ctx
```

## 分布式事务