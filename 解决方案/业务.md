# bitmap 方案

Redis bitmap

# 日志 Log 方案

# 分布式全局唯一ID 

- UUID系列

- snowflake 雪花算法

snowflake（雪花算法）：Twitter 开源的分布式 id 生成算法，64 位的 long 型的 id，分为 4 部分：

1 bit：不用，统一为 0

41 bits：毫秒时间戳，可以表示 69 年的时间。

10 bits：5 bits 代表机房 id，5 个 bits 代表机器 id。最多代表 32 个机房，每个机房最多代表 32 台机器。

12 bits：同一毫秒内的 id，最多 4096 个不同 id，自增模式

依赖机器上的时间。如果机器时间不准，生成ID后，又向校准机器同步了时间，产生“时钟回拨（跳跃）”问题，导致ID冲突

- 自增唯一ID，DB、redis

通过redis的原子操作 INCR 和 INCRBY 获得id。相比数据库自增ID，redis性能更好、更加灵活。不过架构强依赖redis，提高系统复杂度和性能（网络耗时、存储资源）

- 号段模式

自增唯一ID的思路，解决单个实例有上限的问题，分配号段，利于扩展

# 缓存同步 redis 与 DB

https://mp.weixin.qq.com/s/kDVU24W2N-Jgk8PwyUmrow

DB 变化后，如果更新 redis 中的缓存：

多线程操作 redis 会有并发问题，因此首先要采用 cas 策略来进行更新。读redis版本 -> 写DB -> cas更新Redis

读DB写缓存，分成两步，cas 也容易有冲突导致失败，使用lua 或者 分布式互斥锁来保证两部串行。更新DB -> 更新 redis

- 异步更新 redis

订阅 binlog，消费 binlog 流水

- 延时双删

线程B更新DB后，删除缓存，同时A可能已经读取DB老数据，写入缓存，因此 B 在第一次删除缓存后，还需要延迟一会再次删除可能是上个版本的缓存

```
    B -> DB 1-> delete Redis ->      delay delte
A ->            DB 0            -> redis 0
```

# 服务接入安全

## JWT认证(json web token)

1. 服务端查询DB校验姓名密码， 生成token 并返回给前端；
2. 前端缓存到 cookie 或 local storage，下次请求带上token；
3. server 校验 token 签名以及用户信息，不会去查 DB 的

```json
// header.payload.signature
// header
{"alg":"HS256","typ":"JWT"}
// payload
exp (expiration time)：过期时间（jwt的过期时间，这个过期时间必须要大于签发时间）
nbf (Not Before)：生效时间（定义在什么时间之前，该jwt都
// signature
带密钥混淆的hash算法(HMAC)对上面两部分数据签名
```

JWT的payload使用的是base64编码的，因此在JWT中不能存储敏感数据。

JWT的最大缺点是服务器不保存会话状态，所以在使用期间不可能取消令牌或更改令牌的权限。也就是说，一旦JWT签发，在有效期内将会一直有效。

JWT token 一旦泄露，任何人都可以获得令牌的所有权限。为了减少盗用，JWT的有效期不宜设置太长。对于某些重要操作，用户在使用时应该每次都进行身份验证。
