# Feed 流

如何设计一个微博feed流
https://mp.weixin.qq.com/s/W5LypZhFTvGtuRSYTpZONw
如何设计一个微博feed流 - 掘金
https://juejin.cn/post/7025208419875291166

推模式：给所有粉丝收件箱写消息，写扩散；

拉模式：粉丝上线后拉取关注列表的动态信息，读扩散；

推模式适合于粉丝量不大的场景。例如朋友圈，一对一聊天。
拉模式适合粉丝量巨大的大V用户。例如微博大V。

所以在场景设计时，可以将推模式和拉模式结合使用。逻辑如下：

1. 设定一个大V粉丝量阈值。
2. 对于未达到阈值的用户依然使用写扩散方式，这样冗余的数据量不会太大，也不存在即时性问题。
3. 当达到阈值的用户发微博的时候，将微博内容存入缓存（热数据），不进行写扩散，而是粉丝拉取数据与收件箱中的数据进行排序聚合。

PS：这里还可以通过用户行为去维护一个活跃粉丝列表，对于该列表中的粉丝，同样进行一个写扩散的行为，保证即时触达。

# bitmap 方案

Redis bitmap

## 布隆过滤器
一个令人惊艳的算法——布隆过滤器
https://mp.weixin.qq.com/s?src=11&timestamp=1672456805&ver=4259&signature=mq58vwj8PN5T*vqpZfdkI0xpzH4jLiw8lMd9z704eJnxA-HAuYYH3qeI8WmEesLZQynMwEzFlCLfdgoP1*wCy6YVNN6yTrd4UfnLN6HcADuPEUaBt43c44eQp*hbcUgy&new=1



# 日志 Log 方案

# 分布式全局唯一ID 

- UUID系列

- snowflake 雪花算法

snowflake（雪花算法）：Twitter 开源的分布式 id 生成算法，64 位的 long 型的 id，分为 4 部分：

1 bit：不用，统一为 0

41 bits：毫秒时间戳，可以表示 69 年的时间。

10 bits：5 bits 代表机房 id，5 个 bits 代表机器 id。最多代表 32 个机房，每个机房最多代表 32 台机器。

12 bits：同一毫秒内的 id，最多 4096 个不同 id，自增模式

依赖机器上的时间。如果机器时间不准，生成ID后，又向校准机器同步了时间，产生“时钟回拨（跳跃）”问题，导致ID冲突

- 自增唯一ID，DB、redis

通过redis的原子操作 INCR 和 INCRBY 获得id。相比数据库自增ID，redis性能更好、更加灵活。不过架构强依赖redis，提高系统复杂度和性能（网络耗时、存储资源）

- 号段模式

自增唯一ID的思路，解决单个实例有上限的问题，分配号段，利于扩展

# 缓存一致性 redis 与 DB

讲讲 Redis 缓存更新一致性
https://mp.weixin.qq.com/s/kDVU24W2N-Jgk8PwyUmrow
【备】Redis 缓存更新一致性 - -Finley- - 博客园
https://www.cnblogs.com/Finley/p/12615111.html

DB 变化后，如果更新 redis 中的缓存：

多线程操作 redis 会有并发问题，因此首先要采用 cas 策略来进行更新。读redis版本 -> 写DB -> cas更新Redis

读DB写缓存，分成两步，cas 也容易有冲突导致失败，使用lua 或者 分布式互斥锁来保证两部串行。更新DB -> 更新 redis

- 异步更新 redis

订阅 binlog，消费 binlog 流水

- 延时双删

线程B更新DB后，删除缓存，同时A可能已经读取DB老数据，写入缓存，因此 B 在第一次删除缓存后，还需要延迟一会再次删除可能是上个版本的缓存

```
    B -> DB 1-> delete Redis ->      delay delte
A ->            DB 0            -> redis 0
```

# 服务接入安全

## JWT认证(json web token)

1. 服务端查询DB校验姓名密码， 生成token 并返回给前端；
2. 前端缓存到 cookie 或 local storage，下次请求带上token；
3. server 校验 token 签名以及用户信息，不会去查 DB 的

```json
// header.payload.signature
// header
{"alg":"HS256","typ":"JWT"}
// payload
exp (expiration time)：过期时间（jwt的过期时间，这个过期时间必须要大于签发时间）
nbf (Not Before)：生效时间（定义在什么时间之前，该jwt都
// signature
带密钥混淆的hash算法(HMAC)对上面两部分数据签名
```

JWT的payload使用的是base64编码的，因此在JWT中不能存储敏感数据。

JWT的最大缺点是服务器不保存会话状态，所以在使用期间不可能取消令牌或更改令牌的权限。也就是说，一旦JWT签发，在有效期内将会一直有效。

JWT token 一旦泄露，任何人都可以获得令牌的所有权限。为了减少盗用，JWT的有效期不宜设置太长。对于某些重要操作，用户在使用时应该每次都进行身份验证。

# 服务质量

## 断路器 hystrix

```
有三种状态 open、closed 和 half-open：

closed：请求被传递到目标服务。继续监控错误率、请求数和超时等指标。当这些指标超过特定阈值（由开发人员设置）时，断路器将跳闸并转换为open状态。

open：请求不传递给目标服务，而是fallback调用逻辑（由开发人员定义）来处理失败。断路器会在open调用状态保持一段时间sleeping window，之后断路器可以从 open 过渡到 half-open。

half-open：在此状态下，将有限数量的请求传递给目标服务，旨在重置状态。如果目标服务可以成功响应，则 reset 中断返回 closed 状态。否则断路器将转换回open状态。
```

开源项目 `Hystrix` 提供了三种不同的服务降级策略来避免在整个系统中发生 cascading failure 这种情况：

timeout（超时）

maximum concurrent request numbers（最大并发请求数） 和 

request error rate（请求错误率）

## 限流保护

- 漏斗算法/MQ缓冲

请求放入队列，如果达到队列上限，可以选择是否丢弃。

可以允许请求高峰

- 令牌桶

以一定速度往令牌桶里放令牌，直到桶满。请求时先获取令牌，拿不到令牌则失败返回。

不能允许突发流量

- 降级策略

-- 停止边缘业务

比如淘宝双11前，就不可以查询三个月前的订单，对边缘业务进行降级，保证核心业务的高可用。

-- 拒绝请求

在接口请求并发量大于阈值，或是接口出现大量失败请求等等突发情况，可以拒绝一些访问请求。

随机拒绝：随机拒绝超过阈值的请求。

拒绝旧请求：按照请求的时间，优先拒绝更早收到的请求。

拒绝非核心请求：根据系统业务设置核心请求清单，将非核心清单内的请求拒绝掉。
